<!DOCTYPE html>
<body style="font-family: Helvetica,Arial,sans; font-size: 17px;">
<svg id="first" width="300" height="300"></svg>
<svg id="second" width="300" height="300"></svg>
<br/>
<br/>
<br/>
    <input id="log_dt" type="range" min="0" max="3" step="0.05" value="2" style="width:550px;"/>
    <label id="speed">speed</label><br/>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
var waiting_time = Math.pow(10,3-document.getElementById('log_dt').value);
var timer;

    document.getElementById('log_dt').addEventListener('change', function() {
        console.log(+this.value);
        waiting_time = Math.pow(10,3-this.value);
        timer.stop();
        loop();
    });
    document.getElementById('log_dt').addEventListener('input', function() {
        console.log(+this.value);
        waiting_time = Math.pow(10,3-this.value);
        console.log(Math.pow(10,-this.value));
        console.log(waiting_time);

        timer.stop();
        loop();
    });

var svg1 = d3.select("svg#first"),
    width = +svg1.attr("width"),
    height = +svg1.attr("height"),
    color = d3.scaleOrdinal(d3.schemeCategory10);

var svg2 = d3.select("svg#second");

var nods1 = [],
    lings1 = [];

var nods2 = [],
    lings2 = [];

var simulation1;
var simulation2;

var it = 0;
var len_t;

var data_1, data_2;
var these_edges_1;
var g1;

d3.scale

var nod1, ling1;

var nods2 = [],
    lings2 = [];

var is_dtu = false;

// sociopatterns
if (is_dtu){
    // DTU
    var link_distance = 20;
    var node_charge = -5;
    var file1 = "binned_dtu_1_week.taco";
    var file2 = "fw_binned_dtu_1_week.taco";
    var title_content_1 = "DTU Sep '14";
} else {
    var link_distance = 20;
    var node_charge = -10;
    var file1 = "binned_ht09.taco";
    var file2 = "fw_binned_ht09.taco";
    var title_content_1 = "SocioPatterns HT09";
}

var title_content_2 = "flockwork\nsurrogate";


var simulation2;

var it = 0;
var len_t;

var these_edges_2;
var g2;

var nod2, ling2;

var text1, text2;
var title1, title2;

d3.queue()
    //.defer(d3.json,"binned_ht09.taco")
    //.defer(d3.json,"fw_binned_ht09.taco")
    .defer(d3.json,file1)
    .defer(d3.json,file2)
    .await(function(error, _data_1, _data_2){

    console.log(_data_1.t.length);
    console.log(_data_2.t.length);

    data_1 = _data_1;
    data_2 = _data_2;

    for(var n = 0; n < data_1.N; n++)
      nods1.push({"id": n});

    for(var n = 0; n < data_2.N; n++)
      nods2.push({"id": n});

    len_t = data_1.t.length;

    update();


    g1 = svg1.append("g").attr("transform", "translate(" + width / 2 + "," + height / 2 + ")"),
    ling1 = g1.append("g").attr("stroke", "#000").attr("stroke-width", 1.5).selectAll(".ling1"),
    nod1 = g1.append("g").attr("stroke", "#fff").attr("stroke-width", 1.5).selectAll(".nod1");
    text1 = svg1.selectAll("text")
                .data([data_1.t[it]])
                .enter()
                .append("text");
    title1 = svg1
                .append("text")
                .attr("x",width)
                .attr("y",height-5)
                .attr("text-anchor","end")
                .text(title_content_1);


    // Apply the general update pattern to the nods1.
    nod1 = nod1.data(nods1, function(d) { return d.id;});
    nod1.exit().remove();
    nod1 = nod1.enter().append("circle").attr("fill", function(d) { return "black"; }).attr("r", 3).merge(nod1);
    simulation1 = d3.forceSimulation(nods1)
        .force("charge", d3.forceManyBody().strength(node_charge))
        .force("link", d3.forceLink(lings1).distance(link_distance))
        .force("x", d3.forceX())
        .force("y", d3.forceY())
        .alphaTarget(1)
        .on("tick", ticked1);

    g2 = svg2.append("g").attr("transform", "translate(" + width / 2 + "," + height / 2 + ")"),
    ling2 = g2.append("g").attr("stroke", "#000").attr("stroke-width", 1.5).selectAll(".ling2"),
    nod2 = g2.append("g").attr("stroke", "#fff").attr("stroke-width", 1.5).selectAll(".nod2");
    text2 = svg2.selectAll("text")
                .data([data_2[it]])
                .enter()
                .append("text");
    title2 = svg2
                .append("text")
                .attr("x",width)
                .attr("y",height-5)
                .attr("text-anchor","end")
                .text(title_content_2);


    // Apply the general update pattern to the nods1.
    nod2 = nod2.data(nods2, function(d) { return d.id;});
    nod2.exit().remove();
    nod2 = nod2.enter().append("circle").attr("fill", function(d) { return "black"; }).attr("r", 3).merge(nod2);
    simulation2 = d3.forceSimulation(nods2)
        .force("charge", d3.forceManyBody().strength(node_charge))
        .force("link", d3.forceLink(lings2).distance(link_distance))
        .force("x", d3.forceX())
        .force("y", d3.forceY())
        .alphaTarget(1)
        .on("tick", ticked2);
    update_draw();

    loop();

});


function loop()
{
       timer = d3.interval(function(){
                update();
                update_draw();
                }
                ,waiting_time);
}

function update() {

    these_edges_1 = data_1.edges[it];

    lings1.length = 0;
    these_edges_1.forEach(function(edge){
          lings1.push({source: nods1[edge[0]], target: nods1[edge[1]]});
      });

    these_edges_2 = data_2.edges[it];

    lings2.length = 0;
    these_edges_2.forEach(function(edge){
          lings2.push({source: nods2[edge[0]], target: nods2[edge[1]]});
      });

    it += 1;
    if (it==len_t){
        it = 0;
    }

}

function update_draw()
{
    var textLabels1 = text1
                        .attr("x", width)
                        .attr("y", height-23)
                        .attr("text-anchor", "end")
                        .text(d3.format(".2f")(data_1.t[it]/3600.0) + "h");

    var textLabels1 = text2
                        .attr("x", width)
                        .attr("y", height-23)
                        .attr("text-anchor", "end")
                        .text(d3.format(".2f")(data_2.t[it]/3600.0) + "h");

    /*
    text = text1.exit().remove();
    text1 = text1.data([data_1[it]]);
    text1.exit().remove();
    text1 = text1.enter().append("text");
    */

    // Apply the general update pattern to the lings1.
    ling1 = ling1.data(lings1, function(d) { return d.source.id + "-" + d.target.id; });
    ling1.exit().remove();
    ling1 = ling1.enter().append("line").merge(ling1);

    // Update and restart the simulation1.
    simulation1.nodes(nods1);
    simulation1.force("link").links(lings1);
    simulation1.alpha(1).restart();

    // Apply the general update pattern to the lings1.
    ling2 = ling2.data(lings2, function(d) { return d.source.id + "-" + d.target.id; });
    ling2.exit().remove();
    ling2 = ling2.enter().append("line").merge(ling2);

    // Update and restart the simulation1.
    simulation2.nodes(nods2);
    simulation2.force("link").links(lings2);
    simulation2.alpha(1).restart();
}

function ticked1() {
  nod1.attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; })

  ling1.attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; });
}

function ticked2() {
  nod2.attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; })

  ling2.attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; });
}

</script>
</body>
